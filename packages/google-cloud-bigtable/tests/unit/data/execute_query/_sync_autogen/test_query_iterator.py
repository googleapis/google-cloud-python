# Copyright 2024 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# This file is automatically generated by CrossSync. Do not edit manually.

import gc
from google.cloud.bigtable.data import exceptions
from google.cloud.bigtable.data.execute_query.metadata import (
    _pb_metadata_to_metadata_types,
)
import pytest
import concurrent.futures
from ..sql_helpers import chunked_responses, int_val, column, metadata, int64_type
from google.cloud.bigtable.data._cross_sync import CrossSync

try:
    from unittest import mock
except ImportError:
    import mock


class MockIterator:
    def __init__(self, values, delay=None):
        self._values = values
        self.idx = 0
        self._delay = delay

    def __iter__(self):
        return self

    def __next__(self):
        if self.idx >= len(self._values):
            raise CrossSync._Sync_Impl.StopIteration
        if self._delay is not None:
            CrossSync._Sync_Impl.sleep(self._delay)
        value = self._values[self.idx]
        self.idx += 1
        return value


class TestQueryIterator:
    @staticmethod
    def _target_class():
        return CrossSync._Sync_Impl.ExecuteQueryIterator

    def _make_one(self, *args, **kwargs):
        return self._target_class()(*args, **kwargs)

    @pytest.fixture
    def proto_byte_stream(self):
        stream = [
            *chunked_responses(2, int_val(1), int_val(2), token=b"token1"),
            *chunked_responses(3, int_val(3), int_val(4), token=b"token2"),
            *chunked_responses(1, int_val(5), int_val(6), token=b"token3"),
        ]
        return stream

    def test_iterator(self, proto_byte_stream):
        client_mock = mock.Mock()
        client_mock._register_instance = CrossSync._Sync_Impl.Mock()
        client_mock._remove_instance_registration = CrossSync._Sync_Impl.Mock()
        client_mock._executor = concurrent.futures.ThreadPoolExecutor()
        mock_async_iterator = MockIterator(proto_byte_stream)
        iterator = None
        with mock.patch.object(
            CrossSync._Sync_Impl,
            "retry_target_stream",
            return_value=mock_async_iterator,
        ):
            iterator = self._make_one(
                client=client_mock,
                instance_id="test-instance",
                app_profile_id="test_profile",
                request_body={},
                prepare_metadata=_pb_metadata_to_metadata_types(
                    metadata(
                        column("test1", int64_type()), column("test2", int64_type())
                    )
                ),
                attempt_timeout=10,
                operation_timeout=10,
                req_metadata=(),
                retryable_excs=[],
            )
        result = []
        for value in iterator:
            result.append(tuple(value))
        assert result == [(1, 2), (3, 4), (5, 6)]
        assert iterator.is_closed
        client_mock._register_instance.assert_called_once()
        client_mock._remove_instance_registration.assert_called_once()
        assert mock_async_iterator.idx == len(proto_byte_stream)

    def test_iterator_returns_metadata_after_data(self, proto_byte_stream):
        client_mock = mock.Mock()
        client_mock._register_instance = CrossSync._Sync_Impl.Mock()
        client_mock._remove_instance_registration = CrossSync._Sync_Impl.Mock()
        mock_async_iterator = MockIterator(proto_byte_stream)
        iterator = None
        with mock.patch.object(
            CrossSync._Sync_Impl,
            "retry_target_stream",
            return_value=mock_async_iterator,
        ):
            iterator = self._make_one(
                client=client_mock,
                instance_id="test-instance",
                app_profile_id="test_profile",
                request_body={},
                prepare_metadata=_pb_metadata_to_metadata_types(
                    metadata(
                        column("test1", int64_type()), column("test2", int64_type())
                    )
                ),
                attempt_timeout=10,
                operation_timeout=10,
                req_metadata=(),
                retryable_excs=[],
            )
        CrossSync._Sync_Impl.next(iterator)
        assert len(iterator.metadata) == 2
        assert mock_async_iterator.idx == 2

    def test_iterator_throws_error_on_close_w_bufferred_data(self):
        client_mock = mock.Mock()
        client_mock._register_instance = CrossSync._Sync_Impl.Mock()
        client_mock._remove_instance_registration = CrossSync._Sync_Impl.Mock()
        stream = [
            *chunked_responses(2, int_val(1), int_val(2), token=b"token1"),
            *chunked_responses(3, int_val(3), int_val(4), token=b"token2"),
            chunked_responses(2, int_val(5), int_val(6), token=b"token3")[0],
        ]
        mock_async_iterator = MockIterator(stream)
        iterator = None
        with mock.patch.object(
            CrossSync._Sync_Impl,
            "retry_target_stream",
            return_value=mock_async_iterator,
        ):
            iterator = self._make_one(
                client=client_mock,
                instance_id="test-instance",
                app_profile_id="test_profile",
                request_body={},
                prepare_metadata=_pb_metadata_to_metadata_types(
                    metadata(
                        column("test1", int64_type()), column("test2", int64_type())
                    )
                ),
                attempt_timeout=10,
                operation_timeout=10,
                req_metadata=(),
                retryable_excs=[],
            )
        i = 0
        for row in iterator:
            i += 1
            if i == 2:
                break
        with pytest.raises(
            ValueError, match="Unexpected buffered data at end of executeQuery reqest"
        ):
            CrossSync._Sync_Impl.next(iterator)

    def test_iterator_handles_reset(self):
        client_mock = mock.Mock()
        client_mock._register_instance = CrossSync._Sync_Impl.Mock()
        client_mock._remove_instance_registration = CrossSync._Sync_Impl.Mock()
        stream = [
            *chunked_responses(2, int_val(1), int_val(2)),
            *chunked_responses(3, int_val(3), int_val(4), reset=True),
            *chunked_responses(2, int_val(5), int_val(6), reset=False, token=b"token1"),
            chunked_responses(2, int_val(10), int_val(12))[0],
            *chunked_responses(2, int_val(7), int_val(8), token=b"token2"),
        ]
        mock_async_iterator = MockIterator(stream)
        iterator = None
        with mock.patch.object(
            CrossSync._Sync_Impl,
            "retry_target_stream",
            return_value=mock_async_iterator,
        ):
            iterator = self._make_one(
                client=client_mock,
                instance_id="test-instance",
                app_profile_id="test_profile",
                request_body={},
                prepare_metadata=_pb_metadata_to_metadata_types(
                    metadata(
                        column("test1", int64_type()), column("test2", int64_type())
                    )
                ),
                attempt_timeout=10,
                operation_timeout=10,
                req_metadata=(),
                retryable_excs=[],
            )
        results = []
        for value in iterator:
            results.append(value)
        assert len(results) == 3
        [row1, row2, row3] = results
        assert row1["test1"] == 3
        assert row1["test2"] == 4
        assert row2["test1"] == 5
        assert row2["test2"] == 6
        assert row3["test1"] == 7
        assert row3["test2"] == 8

    def test_iterator_returns_error_if_metadata_requested_too_early(
        self, proto_byte_stream
    ):
        client_mock = mock.Mock()
        client_mock._register_instance = CrossSync._Sync_Impl.Mock()
        client_mock._remove_instance_registration = CrossSync._Sync_Impl.Mock()
        mock_async_iterator = MockIterator(proto_byte_stream)
        iterator = None
        with mock.patch.object(
            CrossSync._Sync_Impl,
            "retry_target_stream",
            return_value=mock_async_iterator,
        ):
            iterator = self._make_one(
                client=client_mock,
                instance_id="test-instance",
                app_profile_id="test_profile",
                request_body={},
                prepare_metadata=_pb_metadata_to_metadata_types(
                    metadata(
                        column("test1", int64_type()), column("test2", int64_type())
                    )
                ),
                attempt_timeout=10,
                operation_timeout=10,
                req_metadata=(),
                retryable_excs=[],
            )
        with pytest.raises(exceptions.EarlyMetadataCallError):
            iterator.metadata

    def test_iterator_closes_on_full_consumption(self, proto_byte_stream):
        """Tests that the iterator's close() method is called after all results
        have been successfully consumed."""
        client_mock = mock.Mock()
        client_mock._register_instance = CrossSync._Sync_Impl.Mock()
        client_mock._remove_instance_registration = CrossSync._Sync_Impl.Mock()
        client_mock._executor = concurrent.futures.ThreadPoolExecutor()
        mock_async_iterator = MockIterator(proto_byte_stream)
        with mock.patch.object(
            CrossSync._Sync_Impl,
            "retry_target_stream",
            return_value=mock_async_iterator,
        ):
            iterator = self._make_one(
                client=client_mock,
                instance_id="test-instance",
                app_profile_id="test_profile",
                request_body={},
                prepare_metadata=_pb_metadata_to_metadata_types(
                    metadata(
                        column("test1", int64_type()), column("test2", int64_type())
                    )
                ),
                attempt_timeout=10,
                operation_timeout=10,
            )
            results = [row for row in iterator]
            assert len(results) == 3
        client_mock._remove_instance_registration.assert_called_once()
        assert iterator.is_closed

    def test_iterator_closes_on_early_break(self, proto_byte_stream):
        """Tests that the iterator's close() method is called if the user breaks
        out of the iteration loop early."""
        client_mock = mock.Mock()
        client_mock._register_instance = CrossSync._Sync_Impl.Mock()
        client_mock._remove_instance_registration = CrossSync._Sync_Impl.Mock()
        mock_async_iterator = MockIterator(proto_byte_stream)
        iterator = None
        with mock.patch.object(
            CrossSync._Sync_Impl,
            "retry_target_stream",
            return_value=mock_async_iterator,
        ):
            iterator = CrossSync._Sync_Impl.ExecuteQueryIterator(
                client=client_mock,
                instance_id="test-instance",
                app_profile_id="test_profile",
                request_body={},
                prepare_metadata=_pb_metadata_to_metadata_types(
                    metadata(
                        column("test1", int64_type()), column("test2", int64_type())
                    )
                ),
                attempt_timeout=10,
                operation_timeout=10,
            )
            for _ in iterator:
                break
        del iterator
        CrossSync._Sync_Impl.sleep(1)
        gc.collect()
        CrossSync._Sync_Impl.sleep(1)
        client_mock._remove_instance_registration.assert_called_once()

    def test_iterator_closes_on_error(self, proto_byte_stream):
        """Tests that the iterator's close() method is called if an exception
        is raised during iteration."""
        client_mock = mock.Mock()
        client_mock._register_instance = CrossSync._Sync_Impl.Mock()
        client_mock._remove_instance_registration = CrossSync._Sync_Impl.Mock()

        class MockErrorIterator(MockIterator):
            def __next__(self):
                if self.idx >= 1:
                    raise ValueError("Injected-test-error")
                return super().__next__()

        mock_async_iterator = MockErrorIterator(proto_byte_stream)
        with mock.patch.object(
            CrossSync._Sync_Impl,
            "retry_target_stream",
            return_value=mock_async_iterator,
        ):
            iterator = self._make_one(
                client=client_mock,
                instance_id="test-instance",
                app_profile_id="test_profile",
                request_body={},
                prepare_metadata=_pb_metadata_to_metadata_types(
                    metadata(
                        column("test1", int64_type()), column("test2", int64_type())
                    )
                ),
                attempt_timeout=10,
                operation_timeout=10,
            )
            with pytest.raises(ValueError, match="Injected-test-error"):
                for _ in iterator:
                    pass
        client_mock._remove_instance_registration.assert_called_once()
