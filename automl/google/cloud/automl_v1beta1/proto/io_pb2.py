# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/cloud/automl_v1beta1/proto/io.proto

import sys

_b = sys.version_info[0] < 3 and (lambda x: x) or (lambda x: x.encode("latin1"))
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database

# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


from google.api import annotations_pb2 as google_dot_api_dot_annotations__pb2


DESCRIPTOR = _descriptor.FileDescriptor(
    name="google/cloud/automl_v1beta1/proto/io.proto",
    package="google.cloud.automl.v1beta1",
    syntax="proto3",
    serialized_options=_b(
        "\n\037com.google.cloud.automl.v1beta1P\001ZAgoogle.golang.org/genproto/googleapis/cloud/automl/v1beta1;automl\312\002\033Google\\Cloud\\AutoMl\\V1beta1\352\002\036Google::Cloud::AutoML::V1beta1"
    ),
    serialized_pb=_b(
        '\n*google/cloud/automl_v1beta1/proto/io.proto\x12\x1bgoogle.cloud.automl.v1beta1\x1a\x1cgoogle/api/annotations.proto"\x92\x02\n\x0bInputConfig\x12<\n\ngcs_source\x18\x01 \x01(\x0b\x32&.google.cloud.automl.v1beta1.GcsSourceH\x00\x12\x46\n\x0f\x62igquery_source\x18\x03 \x01(\x0b\x32+.google.cloud.automl.v1beta1.BigQuerySourceH\x00\x12\x44\n\x06params\x18\x02 \x03(\x0b\x32\x34.google.cloud.automl.v1beta1.InputConfig.ParamsEntry\x1a-\n\x0bParamsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\x42\x08\n\x06source"\xa9\x01\n\x17\x42\x61tchPredictInputConfig\x12<\n\ngcs_source\x18\x01 \x01(\x0b\x32&.google.cloud.automl.v1beta1.GcsSourceH\x00\x12\x46\n\x0f\x62igquery_source\x18\x02 \x01(\x0b\x32+.google.cloud.automl.v1beta1.BigQuerySourceH\x00\x42\x08\n\x06source"Q\n\x13\x44ocumentInputConfig\x12:\n\ngcs_source\x18\x01 \x01(\x0b\x32&.google.cloud.automl.v1beta1.GcsSource"\xb7\x01\n\x0cOutputConfig\x12\x46\n\x0fgcs_destination\x18\x01 \x01(\x0b\x32+.google.cloud.automl.v1beta1.GcsDestinationH\x00\x12P\n\x14\x62igquery_destination\x18\x02 \x01(\x0b\x32\x30.google.cloud.automl.v1beta1.BigQueryDestinationH\x00\x42\r\n\x0b\x64\x65stination"\xc3\x01\n\x18\x42\x61tchPredictOutputConfig\x12\x46\n\x0fgcs_destination\x18\x01 \x01(\x0b\x32+.google.cloud.automl.v1beta1.GcsDestinationH\x00\x12P\n\x14\x62igquery_destination\x18\x02 \x01(\x0b\x32\x30.google.cloud.automl.v1beta1.BigQueryDestinationH\x00\x42\r\n\x0b\x64\x65stination"\xcf\x02\n\x17ModelExportOutputConfig\x12\x46\n\x0fgcs_destination\x18\x01 \x01(\x0b\x32+.google.cloud.automl.v1beta1.GcsDestinationH\x00\x12\x46\n\x0fgcr_destination\x18\x03 \x01(\x0b\x32+.google.cloud.automl.v1beta1.GcrDestinationH\x00\x12\x14\n\x0cmodel_format\x18\x04 \x01(\t\x12P\n\x06params\x18\x02 \x03(\x0b\x32@.google.cloud.automl.v1beta1.ModelExportOutputConfig.ParamsEntry\x1a-\n\x0bParamsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\x42\r\n\x0b\x64\x65stination"\x86\x01\n#ExportEvaluatedExamplesOutputConfig\x12P\n\x14\x62igquery_destination\x18\x02 \x01(\x0b\x32\x30.google.cloud.automl.v1beta1.BigQueryDestinationH\x00\x42\r\n\x0b\x64\x65stination"\x1f\n\tGcsSource\x12\x12\n\ninput_uris\x18\x01 \x03(\t"#\n\x0e\x42igQuerySource\x12\x11\n\tinput_uri\x18\x01 \x01(\t"+\n\x0eGcsDestination\x12\x19\n\x11output_uri_prefix\x18\x01 \x01(\t")\n\x13\x42igQueryDestination\x12\x12\n\noutput_uri\x18\x01 \x01(\t"$\n\x0eGcrDestination\x12\x12\n\noutput_uri\x18\x01 \x01(\tB\xa5\x01\n\x1f\x63om.google.cloud.automl.v1beta1P\x01ZAgoogle.golang.org/genproto/googleapis/cloud/automl/v1beta1;automl\xca\x02\x1bGoogle\\Cloud\\AutoMl\\V1beta1\xea\x02\x1eGoogle::Cloud::AutoML::V1beta1b\x06proto3'
    ),
    dependencies=[google_dot_api_dot_annotations__pb2.DESCRIPTOR],
)


_INPUTCONFIG_PARAMSENTRY = _descriptor.Descriptor(
    name="ParamsEntry",
    full_name="google.cloud.automl.v1beta1.InputConfig.ParamsEntry",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="key",
            full_name="google.cloud.automl.v1beta1.InputConfig.ParamsEntry.key",
            index=0,
            number=1,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="value",
            full_name="google.cloud.automl.v1beta1.InputConfig.ParamsEntry.value",
            index=1,
            number=2,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=_b("8\001"),
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=325,
    serialized_end=370,
)

_INPUTCONFIG = _descriptor.Descriptor(
    name="InputConfig",
    full_name="google.cloud.automl.v1beta1.InputConfig",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="gcs_source",
            full_name="google.cloud.automl.v1beta1.InputConfig.gcs_source",
            index=0,
            number=1,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="bigquery_source",
            full_name="google.cloud.automl.v1beta1.InputConfig.bigquery_source",
            index=1,
            number=3,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="params",
            full_name="google.cloud.automl.v1beta1.InputConfig.params",
            index=2,
            number=2,
            type=11,
            cpp_type=10,
            label=3,
            has_default_value=False,
            default_value=[],
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
    ],
    extensions=[],
    nested_types=[_INPUTCONFIG_PARAMSENTRY],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[
        _descriptor.OneofDescriptor(
            name="source",
            full_name="google.cloud.automl.v1beta1.InputConfig.source",
            index=0,
            containing_type=None,
            fields=[],
        )
    ],
    serialized_start=106,
    serialized_end=380,
)


_BATCHPREDICTINPUTCONFIG = _descriptor.Descriptor(
    name="BatchPredictInputConfig",
    full_name="google.cloud.automl.v1beta1.BatchPredictInputConfig",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="gcs_source",
            full_name="google.cloud.automl.v1beta1.BatchPredictInputConfig.gcs_source",
            index=0,
            number=1,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="bigquery_source",
            full_name="google.cloud.automl.v1beta1.BatchPredictInputConfig.bigquery_source",
            index=1,
            number=2,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[
        _descriptor.OneofDescriptor(
            name="source",
            full_name="google.cloud.automl.v1beta1.BatchPredictInputConfig.source",
            index=0,
            containing_type=None,
            fields=[],
        )
    ],
    serialized_start=383,
    serialized_end=552,
)


_DOCUMENTINPUTCONFIG = _descriptor.Descriptor(
    name="DocumentInputConfig",
    full_name="google.cloud.automl.v1beta1.DocumentInputConfig",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="gcs_source",
            full_name="google.cloud.automl.v1beta1.DocumentInputConfig.gcs_source",
            index=0,
            number=1,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        )
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=554,
    serialized_end=635,
)


_OUTPUTCONFIG = _descriptor.Descriptor(
    name="OutputConfig",
    full_name="google.cloud.automl.v1beta1.OutputConfig",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="gcs_destination",
            full_name="google.cloud.automl.v1beta1.OutputConfig.gcs_destination",
            index=0,
            number=1,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="bigquery_destination",
            full_name="google.cloud.automl.v1beta1.OutputConfig.bigquery_destination",
            index=1,
            number=2,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[
        _descriptor.OneofDescriptor(
            name="destination",
            full_name="google.cloud.automl.v1beta1.OutputConfig.destination",
            index=0,
            containing_type=None,
            fields=[],
        )
    ],
    serialized_start=638,
    serialized_end=821,
)


_BATCHPREDICTOUTPUTCONFIG = _descriptor.Descriptor(
    name="BatchPredictOutputConfig",
    full_name="google.cloud.automl.v1beta1.BatchPredictOutputConfig",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="gcs_destination",
            full_name="google.cloud.automl.v1beta1.BatchPredictOutputConfig.gcs_destination",
            index=0,
            number=1,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="bigquery_destination",
            full_name="google.cloud.automl.v1beta1.BatchPredictOutputConfig.bigquery_destination",
            index=1,
            number=2,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[
        _descriptor.OneofDescriptor(
            name="destination",
            full_name="google.cloud.automl.v1beta1.BatchPredictOutputConfig.destination",
            index=0,
            containing_type=None,
            fields=[],
        )
    ],
    serialized_start=824,
    serialized_end=1019,
)


_MODELEXPORTOUTPUTCONFIG_PARAMSENTRY = _descriptor.Descriptor(
    name="ParamsEntry",
    full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.ParamsEntry",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="key",
            full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.ParamsEntry.key",
            index=0,
            number=1,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="value",
            full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.ParamsEntry.value",
            index=1,
            number=2,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=_b("8\001"),
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=325,
    serialized_end=370,
)

_MODELEXPORTOUTPUTCONFIG = _descriptor.Descriptor(
    name="ModelExportOutputConfig",
    full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="gcs_destination",
            full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.gcs_destination",
            index=0,
            number=1,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="gcr_destination",
            full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.gcr_destination",
            index=1,
            number=3,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="model_format",
            full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.model_format",
            index=2,
            number=4,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
        _descriptor.FieldDescriptor(
            name="params",
            full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.params",
            index=3,
            number=2,
            type=11,
            cpp_type=10,
            label=3,
            has_default_value=False,
            default_value=[],
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        ),
    ],
    extensions=[],
    nested_types=[_MODELEXPORTOUTPUTCONFIG_PARAMSENTRY],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[
        _descriptor.OneofDescriptor(
            name="destination",
            full_name="google.cloud.automl.v1beta1.ModelExportOutputConfig.destination",
            index=0,
            containing_type=None,
            fields=[],
        )
    ],
    serialized_start=1022,
    serialized_end=1357,
)


_EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG = _descriptor.Descriptor(
    name="ExportEvaluatedExamplesOutputConfig",
    full_name="google.cloud.automl.v1beta1.ExportEvaluatedExamplesOutputConfig",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="bigquery_destination",
            full_name="google.cloud.automl.v1beta1.ExportEvaluatedExamplesOutputConfig.bigquery_destination",
            index=0,
            number=2,
            type=11,
            cpp_type=10,
            label=1,
            has_default_value=False,
            default_value=None,
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        )
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[
        _descriptor.OneofDescriptor(
            name="destination",
            full_name="google.cloud.automl.v1beta1.ExportEvaluatedExamplesOutputConfig.destination",
            index=0,
            containing_type=None,
            fields=[],
        )
    ],
    serialized_start=1360,
    serialized_end=1494,
)


_GCSSOURCE = _descriptor.Descriptor(
    name="GcsSource",
    full_name="google.cloud.automl.v1beta1.GcsSource",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="input_uris",
            full_name="google.cloud.automl.v1beta1.GcsSource.input_uris",
            index=0,
            number=1,
            type=9,
            cpp_type=9,
            label=3,
            has_default_value=False,
            default_value=[],
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        )
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=1496,
    serialized_end=1527,
)


_BIGQUERYSOURCE = _descriptor.Descriptor(
    name="BigQuerySource",
    full_name="google.cloud.automl.v1beta1.BigQuerySource",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="input_uri",
            full_name="google.cloud.automl.v1beta1.BigQuerySource.input_uri",
            index=0,
            number=1,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        )
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=1529,
    serialized_end=1564,
)


_GCSDESTINATION = _descriptor.Descriptor(
    name="GcsDestination",
    full_name="google.cloud.automl.v1beta1.GcsDestination",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="output_uri_prefix",
            full_name="google.cloud.automl.v1beta1.GcsDestination.output_uri_prefix",
            index=0,
            number=1,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        )
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=1566,
    serialized_end=1609,
)


_BIGQUERYDESTINATION = _descriptor.Descriptor(
    name="BigQueryDestination",
    full_name="google.cloud.automl.v1beta1.BigQueryDestination",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="output_uri",
            full_name="google.cloud.automl.v1beta1.BigQueryDestination.output_uri",
            index=0,
            number=1,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        )
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=1611,
    serialized_end=1652,
)


_GCRDESTINATION = _descriptor.Descriptor(
    name="GcrDestination",
    full_name="google.cloud.automl.v1beta1.GcrDestination",
    filename=None,
    file=DESCRIPTOR,
    containing_type=None,
    fields=[
        _descriptor.FieldDescriptor(
            name="output_uri",
            full_name="google.cloud.automl.v1beta1.GcrDestination.output_uri",
            index=0,
            number=1,
            type=9,
            cpp_type=9,
            label=1,
            has_default_value=False,
            default_value=_b("").decode("utf-8"),
            message_type=None,
            enum_type=None,
            containing_type=None,
            is_extension=False,
            extension_scope=None,
            serialized_options=None,
            file=DESCRIPTOR,
        )
    ],
    extensions=[],
    nested_types=[],
    enum_types=[],
    serialized_options=None,
    is_extendable=False,
    syntax="proto3",
    extension_ranges=[],
    oneofs=[],
    serialized_start=1654,
    serialized_end=1690,
)

_INPUTCONFIG_PARAMSENTRY.containing_type = _INPUTCONFIG
_INPUTCONFIG.fields_by_name["gcs_source"].message_type = _GCSSOURCE
_INPUTCONFIG.fields_by_name["bigquery_source"].message_type = _BIGQUERYSOURCE
_INPUTCONFIG.fields_by_name["params"].message_type = _INPUTCONFIG_PARAMSENTRY
_INPUTCONFIG.oneofs_by_name["source"].fields.append(
    _INPUTCONFIG.fields_by_name["gcs_source"]
)
_INPUTCONFIG.fields_by_name[
    "gcs_source"
].containing_oneof = _INPUTCONFIG.oneofs_by_name["source"]
_INPUTCONFIG.oneofs_by_name["source"].fields.append(
    _INPUTCONFIG.fields_by_name["bigquery_source"]
)
_INPUTCONFIG.fields_by_name[
    "bigquery_source"
].containing_oneof = _INPUTCONFIG.oneofs_by_name["source"]
_BATCHPREDICTINPUTCONFIG.fields_by_name["gcs_source"].message_type = _GCSSOURCE
_BATCHPREDICTINPUTCONFIG.fields_by_name[
    "bigquery_source"
].message_type = _BIGQUERYSOURCE
_BATCHPREDICTINPUTCONFIG.oneofs_by_name["source"].fields.append(
    _BATCHPREDICTINPUTCONFIG.fields_by_name["gcs_source"]
)
_BATCHPREDICTINPUTCONFIG.fields_by_name[
    "gcs_source"
].containing_oneof = _BATCHPREDICTINPUTCONFIG.oneofs_by_name["source"]
_BATCHPREDICTINPUTCONFIG.oneofs_by_name["source"].fields.append(
    _BATCHPREDICTINPUTCONFIG.fields_by_name["bigquery_source"]
)
_BATCHPREDICTINPUTCONFIG.fields_by_name[
    "bigquery_source"
].containing_oneof = _BATCHPREDICTINPUTCONFIG.oneofs_by_name["source"]
_DOCUMENTINPUTCONFIG.fields_by_name["gcs_source"].message_type = _GCSSOURCE
_OUTPUTCONFIG.fields_by_name["gcs_destination"].message_type = _GCSDESTINATION
_OUTPUTCONFIG.fields_by_name["bigquery_destination"].message_type = _BIGQUERYDESTINATION
_OUTPUTCONFIG.oneofs_by_name["destination"].fields.append(
    _OUTPUTCONFIG.fields_by_name["gcs_destination"]
)
_OUTPUTCONFIG.fields_by_name[
    "gcs_destination"
].containing_oneof = _OUTPUTCONFIG.oneofs_by_name["destination"]
_OUTPUTCONFIG.oneofs_by_name["destination"].fields.append(
    _OUTPUTCONFIG.fields_by_name["bigquery_destination"]
)
_OUTPUTCONFIG.fields_by_name[
    "bigquery_destination"
].containing_oneof = _OUTPUTCONFIG.oneofs_by_name["destination"]
_BATCHPREDICTOUTPUTCONFIG.fields_by_name[
    "gcs_destination"
].message_type = _GCSDESTINATION
_BATCHPREDICTOUTPUTCONFIG.fields_by_name[
    "bigquery_destination"
].message_type = _BIGQUERYDESTINATION
_BATCHPREDICTOUTPUTCONFIG.oneofs_by_name["destination"].fields.append(
    _BATCHPREDICTOUTPUTCONFIG.fields_by_name["gcs_destination"]
)
_BATCHPREDICTOUTPUTCONFIG.fields_by_name[
    "gcs_destination"
].containing_oneof = _BATCHPREDICTOUTPUTCONFIG.oneofs_by_name["destination"]
_BATCHPREDICTOUTPUTCONFIG.oneofs_by_name["destination"].fields.append(
    _BATCHPREDICTOUTPUTCONFIG.fields_by_name["bigquery_destination"]
)
_BATCHPREDICTOUTPUTCONFIG.fields_by_name[
    "bigquery_destination"
].containing_oneof = _BATCHPREDICTOUTPUTCONFIG.oneofs_by_name["destination"]
_MODELEXPORTOUTPUTCONFIG_PARAMSENTRY.containing_type = _MODELEXPORTOUTPUTCONFIG
_MODELEXPORTOUTPUTCONFIG.fields_by_name[
    "gcs_destination"
].message_type = _GCSDESTINATION
_MODELEXPORTOUTPUTCONFIG.fields_by_name[
    "gcr_destination"
].message_type = _GCRDESTINATION
_MODELEXPORTOUTPUTCONFIG.fields_by_name[
    "params"
].message_type = _MODELEXPORTOUTPUTCONFIG_PARAMSENTRY
_MODELEXPORTOUTPUTCONFIG.oneofs_by_name["destination"].fields.append(
    _MODELEXPORTOUTPUTCONFIG.fields_by_name["gcs_destination"]
)
_MODELEXPORTOUTPUTCONFIG.fields_by_name[
    "gcs_destination"
].containing_oneof = _MODELEXPORTOUTPUTCONFIG.oneofs_by_name["destination"]
_MODELEXPORTOUTPUTCONFIG.oneofs_by_name["destination"].fields.append(
    _MODELEXPORTOUTPUTCONFIG.fields_by_name["gcr_destination"]
)
_MODELEXPORTOUTPUTCONFIG.fields_by_name[
    "gcr_destination"
].containing_oneof = _MODELEXPORTOUTPUTCONFIG.oneofs_by_name["destination"]
_EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG.fields_by_name[
    "bigquery_destination"
].message_type = _BIGQUERYDESTINATION
_EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG.oneofs_by_name["destination"].fields.append(
    _EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG.fields_by_name["bigquery_destination"]
)
_EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG.fields_by_name[
    "bigquery_destination"
].containing_oneof = _EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG.oneofs_by_name["destination"]
DESCRIPTOR.message_types_by_name["InputConfig"] = _INPUTCONFIG
DESCRIPTOR.message_types_by_name["BatchPredictInputConfig"] = _BATCHPREDICTINPUTCONFIG
DESCRIPTOR.message_types_by_name["DocumentInputConfig"] = _DOCUMENTINPUTCONFIG
DESCRIPTOR.message_types_by_name["OutputConfig"] = _OUTPUTCONFIG
DESCRIPTOR.message_types_by_name["BatchPredictOutputConfig"] = _BATCHPREDICTOUTPUTCONFIG
DESCRIPTOR.message_types_by_name["ModelExportOutputConfig"] = _MODELEXPORTOUTPUTCONFIG
DESCRIPTOR.message_types_by_name[
    "ExportEvaluatedExamplesOutputConfig"
] = _EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG
DESCRIPTOR.message_types_by_name["GcsSource"] = _GCSSOURCE
DESCRIPTOR.message_types_by_name["BigQuerySource"] = _BIGQUERYSOURCE
DESCRIPTOR.message_types_by_name["GcsDestination"] = _GCSDESTINATION
DESCRIPTOR.message_types_by_name["BigQueryDestination"] = _BIGQUERYDESTINATION
DESCRIPTOR.message_types_by_name["GcrDestination"] = _GCRDESTINATION
_sym_db.RegisterFileDescriptor(DESCRIPTOR)

InputConfig = _reflection.GeneratedProtocolMessageType(
    "InputConfig",
    (_message.Message,),
    dict(
        ParamsEntry=_reflection.GeneratedProtocolMessageType(
            "ParamsEntry",
            (_message.Message,),
            dict(
                DESCRIPTOR=_INPUTCONFIG_PARAMSENTRY,
                __module__="google.cloud.automl_v1beta1.proto.io_pb2"
                # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.InputConfig.ParamsEntry)
            ),
        ),
        DESCRIPTOR=_INPUTCONFIG,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""Input configuration for ImportData Action.
  
  The format of input depends on dataset\_metadata the Dataset into which
  the import is happening has. As input source the
  [gcs\_source][google.cloud.automl.v1beta1.InputConfig.gcs\_source] is
  expected, unless specified otherwise. Additionally any input .CSV file
  by itself must be 100MB or smaller, unless specified otherwise. If an
  "example" file (that is, image, video etc.) with identical content (even
  if it had different GCS\_FILE\_PATH) is mentioned multiple times, then
  its label, bounding boxes etc. are appended. The same file should be
  always provided with the same ML\_USE and GCS\_FILE\_PATH, if it is not,
  then these values are nondeterministically selected from the given ones.
  
  The formats are represented in EBNF with commas being literal and with
  non-terminal symbols defined near the end of this comment. The formats
  are:
  
  -  For Image Classification: CSV file(s) with each line in format:
     ML\_USE,GCS\_FILE\_PATH,LABEL,LABEL,... GCS\_FILE\_PATH leads to
     image of up to 30MB in size. Supported extensions: .JPEG, .GIF, .PNG,
     .WEBP, .BMP, .TIFF, .ICO For MULTICLASS classification type, at most
     one LABEL is allowed per image. If an image has not yet been labeled,
     then it should be mentioned just once with no LABEL. Some sample
     rows: TRAIN,gs://folder/image1.jpg,daisy
     TEST,gs://folder/image2.jpg,dandelion,tulip,rose
     UNASSIGNED,gs://folder/image3.jpg,daisy
     UNASSIGNED,gs://folder/image4.jpg
  
  -  For Image Object Detection: CSV file(s) with each line in format:
     ML\_USE,GCS\_FILE\_PATH,(LABEL,BOUNDING\_BOX \| ,,,,,,,)
     GCS\_FILE\_PATH leads to image of up to 30MB in size. Supported
     extensions: .JPEG, .GIF, .PNG. Each image is assumed to be
     exhaustively labeled. The minimum allowed BOUNDING\_BOX edge length
     is 0.01, and no more than 500 BOUNDING\_BOX-es per image are allowed
     (one BOUNDING\_BOX is defined per line). If an image has not yet been
     labeled, then it should be mentioned just once with no LABEL and the
     ",,,,,,," in place of the BOUNDING\_BOX. For images which are known
     to not contain any bounding boxes, they should be labelled explictly
     as "NEGATIVE\_IMAGE", followed by ",,,,,,," in place of the
     BOUNDING\_BOX. Sample rows:
     TRAIN,gs://folder/image1.png,car,0.1,0.1,,,0.3,0.3,,
     TRAIN,gs://folder/image1.png,bike,.7,.6,,,.8,.9,,
     UNASSIGNED,gs://folder/im2.png,car,0.1,0.1,0.2,0.1,0.2,0.3,0.1,0.3
     TEST,gs://folder/im3.png,,,,,,,,,
     TRAIN,gs://folder/im4.png,NEGATIVE\_IMAGE,,,,,,,,,
  
  -  For Video Classification: CSV file(s) with each line in format:
     ML\_USE,GCS\_FILE\_PATH where ML\_USE VALIDATE value should not be
     used. The GCS\_FILE\_PATH should lead to another .csv file which
     describes examples that have given ML\_USE, using the following row
     format:
     GCS\_FILE\_PATH,(LABEL,TIME\_SEGMENT\_START,TIME\_SEGMENT\_END \| ,,)
     Here GCS\_FILE\_PATH leads to a video of up to 50GB in size and up to
     3h duration. Supported extensions: .MOV, .MPEG4, .MP4, .AVI.
     TIME\_SEGMENT\_START and TIME\_SEGMENT\_END must be within the length
     of the video, and end has to be after the start. Any segment of a
     video which has one or more labels on it, is considered a hard
     negative for all other labels. Any segment with no labels on it is
     considered to be unknown. If a whole video is unknown, then it shuold
     be mentioned just once with ",," in place of LABEL,
     TIME\_SEGMENT\_START,TIME\_SEGMENT\_END. Sample top level CSV file:
     TRAIN,gs://folder/train\_videos.csv TEST,gs://folder/test\_videos.csv
     UNASSIGNED,gs://folder/other\_videos.csv Sample rows of a CSV file
     for a particular ML\_USE: gs://folder/video1.avi,car,120,180.000021
     gs://folder/video1.avi,bike,150,180.000021
     gs://folder/vid2.avi,car,0,60.5 gs://folder/vid3.avi,,,
  
  -  For Video Object Tracking: CSV file(s) with each line in format:
     ML\_USE,GCS\_FILE\_PATH where ML\_USE VALIDATE value should not be
     used. The GCS\_FILE\_PATH should lead to another .csv file which
     describes examples that have given ML\_USE, using one of the
     following row format:
     GCS\_FILE\_PATH,LABEL,[INSTANCE\_ID],TIMESTAMP,BOUNDING\_BOX or
     GCS\_FILE\_PATH,,,,,,,,,, Here GCS\_FILE\_PATH leads to a video of up
     to 50GB in size and up to 3h duration. Supported extensions: .MOV,
     .MPEG4, .MP4, .AVI. Providing INSTANCE\_IDs can help to obtain a
     better model. When a specific labeled entity leaves the video frame,
     and shows up afterwards it is not required, albeit preferable, that
     the same INSTANCE\_ID is given to it. TIMESTAMP must be within the
     length of the video, the BOUNDING\_BOX is assumed to be drawn on the
     closest video's frame to the TIMESTAMP. Any mentioned by the
     TIMESTAMP frame is expected to be exhaustively labeled and no more
     than 500 BOUNDING\_BOX-es per frame are allowed. If a whole video is
     unknown, then it should be mentioned just once with ",,,,,,,,,," in
     place of LABEL, [INSTANCE\_ID],TIMESTAMP,BOUNDING\_BOX. Sample top
     level CSV file: TRAIN,gs://folder/train\_videos.csv
     TEST,gs://folder/test\_videos.csv
     UNASSIGNED,gs://folder/other\_videos.csv Seven sample rows of a CSV
     file for a particular ML\_USE:
     gs://folder/video1.avi,car,1,12.10,0.8,0.8,0.9,0.8,0.9,0.9,0.8,0.9
     gs://folder/video1.avi,car,1,12.90,0.4,0.8,0.5,0.8,0.5,0.9,0.4,0.9
     gs://folder/video1.avi,car,2,12.10,.4,.2,.5,.2,.5,.3,.4,.3
     gs://folder/video1.avi,car,2,12.90,.8,.2,,,.9,.3,,
     gs://folder/video1.avi,bike,,12.50,.45,.45,,,.55,.55,,
     gs://folder/video2.avi,car,1,0,.1,.9,,,.9,.1,,
     gs://folder/video2.avi,,,,,,,,,,,
  -  For Text Extraction: CSV file(s) with each line in format:
     ML\_USE,GCS\_FILE\_PATH GCS\_FILE\_PATH leads to a .JSONL (that is,
     JSON Lines) file which either imports text in-line or as documents.
     Any given .JSONL file must be 100MB or smaller. The in-line .JSONL
     file contains, per line, a proto that wraps a TextSnippet proto (in
     json representation) followed by one or more AnnotationPayload protos
     (called annotations), which have display\_name and text\_extraction
     detail populated. The given text is expected to be annotated
     exhaustively, for example, if you look for animals and text contains
     "dolphin" that is not labeled, then "dolphin" is assumed to not be an
     animal. Any given text snippet content must be 10KB or smaller, and
     also be UTF-8 NFC encoded (ASCII already is). The document .JSONL
     file contains, per line, a proto that wraps a Document proto. The
     Document proto must have either document\_text or input\_config set.
     In document\_text case, the Document proto may also contain the
     spatial information of the document, including layout, document
     dimension and page number. In input\_config case, only PDF documents
     are supported now, and each document may be up to 2MB large.
     Currently, annotations on documents cannot be specified at import.
     Three sample CSV rows: TRAIN,gs://folder/file1.jsonl
     VALIDATE,gs://folder/file2.jsonl TEST,gs://folder/file3.jsonl 
  
  -  For Text Classification: CSV file(s) with each line in format:
     ML\_USE,(TEXT\_SNIPPET \| GCS\_FILE\_PATH),LABEL,LABEL,...
     TEXT\_SNIPPET and GCS\_FILE\_PATH are distinguished by a pattern. If
     the column content is a valid gcs file path, i.e. prefixed by
     "gs://", it will be treated as a GCS\_FILE\_PATH, else if the content
     is enclosed within double quotes (""), it is treated as a
     TEXT\_SNIPPET. In the GCS\_FILE\_PATH case, the path must lead to a
     .txt file with UTF-8 encoding, for example,
     "gs://folder/content.txt", and the content in it is extracted as a
     text snippet. In TEXT\_SNIPPET case, the column content excluding
     quotes is treated as to be imported text snippet. In both cases, the
     text snippet/file size must be within 128kB. Maximum 100 unique
     labels are allowed per CSV row. Sample rows: TRAIN,"They have bad
     food and very rude",RudeService,BadFood
     TRAIN,gs://folder/content.txt,SlowService TEST,"Typically always bad
     service there.",RudeService VALIDATE,"Stomach ache to go.",BadFood
  
  -  For Text Sentiment: CSV file(s) with each line in format:
     ML\_USE,(TEXT\_SNIPPET \| GCS\_FILE\_PATH),SENTIMENT TEXT\_SNIPPET
     and GCS\_FILE\_PATH are distinguished by a pattern. If the column
     content is a valid gcs file path, that is, prefixed by "gs://", it is
     treated as a GCS\_FILE\_PATH, otherwise it is treated as a
     TEXT\_SNIPPET. In the GCS\_FILE\_PATH case, the path must lead to a
     .txt file with UTF-8 encoding, for example,
     "gs://folder/content.txt", and the content in it is extracted as a
     text snippet. In TEXT\_SNIPPET case, the column content itself is
     treated as to be imported text snippet. In both cases, the text
     snippet must be up to 500 characters long. Sample rows:
     TRAIN,"@freewrytin this is way too good for your product",2 TRAIN,"I
     need this product so bad",3 TEST,"Thank you for this product.",4
     VALIDATE,gs://folder/content.txt,2
  
  -  For Tables: Either
     [gcs\_source][google.cloud.automl.v1beta1.InputConfig.gcs\_source] or
  
  [bigquery\_source][google.cloud.automl.v1beta1.InputConfig.bigquery\_source]
  can be used. All inputs is concatenated into a single
  
  [primary\_table][google.cloud.automl.v1beta1.TablesDatasetMetadata.primary\_table\_name]
  For gcs\_source: CSV file(s), where the first row of the first file is
  the header, containing unique column names. If the first row of a
  subsequent file is the same as the header, then it is also treated as a
  header. All other rows contain values for the corresponding columns.
  Each .CSV file by itself must be 10GB or smaller, and their total size
  must be 100GB or smaller. First three sample rows of a CSV file:
  "Id","First Name","Last Name","Dob","Addresses"
  
  "1","John","Doe","1968-01-22","[{"status":"current","address":"123\_First\_Avenue","city":"Seattle","state":"WA","zip":"11111","numberOfYears":"1"},{"status":"previous","address":"456\_Main\_Street","city":"Portland","state":"OR","zip":"22222","numberOfYears":"5"}]"
  
  "2","Jane","Doe","1980-10-16","[{"status":"current","address":"789\_Any\_Avenue","city":"Albany","state":"NY","zip":"33333","numberOfYears":"2"},{"status":"previous","address":"321\_Main\_Street","city":"Hoboken","state":"NJ","zip":"44444","numberOfYears":"3"}]}
  For bigquery\_source: An URI of a BigQuery table. The user data size of
  the BigQuery table must be 100GB or smaller. An imported table must have
  between 2 and 1,000 columns, inclusive, and between 1000 and 100,000,000
  rows, inclusive. There are at most 5 import data running in parallel.
  Definitions: ML\_USE = "TRAIN" \| "VALIDATE" \| "TEST" \| "UNASSIGNED"
  Describes how the given example (file) should be used for model
  training. "UNASSIGNED" can be used when user has no preference.
  GCS\_FILE\_PATH = A path to file on GCS, e.g. "gs://folder/image1.png".
  LABEL = A display name of an object on an image, video etc., e.g. "dog".
  Must be up to 32 characters long and can consist only of ASCII Latin
  letters A-Z and a-z, underscores(\_), and ASCII digits 0-9. For each
  label an AnnotationSpec is created which display\_name becomes the
  label; AnnotationSpecs are given back in predictions. INSTANCE\_ID = A
  positive integer that identifies a specific instance of a labeled entity
  on an example. Used e.g. to track two cars on a video while being able
  to tell apart which one is which. BOUNDING\_BOX =
  VERTEX,VERTEX,VERTEX,VERTEX \| VERTEX,,,VERTEX,, A rectangle parallel to
  the frame of the example (image, video). If 4 vertices are given they
  are connected by edges in the order provided, if 2 are given they are
  recognized as diagonally opposite vertices of the rectangle. VERTEX =
  COORDINATE,COORDINATE First coordinate is horizontal (x), the second is
  vertical (y). COORDINATE = A float in 0 to 1 range, relative to total
  length of image or video in given dimension. For fractions the leading
  non-decimal 0 can be omitted (i.e. 0.3 = .3). Point 0,0 is in top left.
  TIME\_SEGMENT\_START = TIME\_OFFSET Expresses a beginning, inclusive, of
  a time segment within an example that has a time dimension (e.g. video).
  TIME\_SEGMENT\_END = TIME\_OFFSET Expresses an end, exclusive, of a time
  segment within an example that has a time dimension (e.g. video).
  TIME\_OFFSET = A number of seconds as measured from the start of an
  example (e.g. video). Fractions are allowed, up to a microsecond
  precision. "inf" is allowed, and it means the end of the example.
  TEXT\_SNIPPET = A content of a text snippet, UTF-8 encoded, enclosed
  within double quotes (""). SENTIMENT = An integer between 0 and
  Dataset.text\_sentiment\_dataset\_metadata.sentiment\_max (inclusive).
  Describes the ordinal of the sentiment - higher value means a more
  positive sentiment. All the values are completely relative, i.e. neither
  0 needs to mean a negative or neutral sentiment nor sentiment\_max needs
  to mean a positive one - it is just required that 0 is the least
  positive sentiment in the data, and sentiment\_max is the most positive
  one. The SENTIMENT shouldn't be confused with "score" or "magnitude"
  from the previous Natural Language Sentiment Analysis API. All SENTIMENT
  values between 0 and sentiment\_max must be represented in the imported
  data. On prediction the same 0 to sentiment\_max range will be used. The
  difference between neighboring sentiment values needs not to be uniform,
  e.g. 1 and 2 may be similar whereas the difference between 2 and 3 may
  be huge.
  
  Errors: If any of the provided CSV files can't be parsed or if more than
  certain percent of CSV rows cannot be processed then the operation fails
  and nothing is imported. Regardless of overall success or failure the
  per-row failures, up to a certain count cap, is listed in
  Operation.metadata.partial\_failures.
  
  
  Attributes:
      source:
          The source of the input.
      gcs_source:
          The Google Cloud Storage location for the input content. In
          ImportData, the gcs\_source points to a csv with structure
          described in the comment.
      bigquery_source:
          The BigQuery location for the input content.
      params:
          Additional domain-specific parameters describing the semantic
          of the imported data, any string must be up to 25000
          characters long.  -  For Tables: ``schema_inference_version``
          - (integer) Required. The    version of the algorithm that
          should be used for the initial    inference of the schema
          (columns' DataTypes) of the table the data is    being
          imported into. Allowed values: "1".
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.InputConfig)
    ),
)
_sym_db.RegisterMessage(InputConfig)
_sym_db.RegisterMessage(InputConfig.ParamsEntry)

BatchPredictInputConfig = _reflection.GeneratedProtocolMessageType(
    "BatchPredictInputConfig",
    (_message.Message,),
    dict(
        DESCRIPTOR=_BATCHPREDICTINPUTCONFIG,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""Input configuration for BatchPredict Action.
  
  The format of input depends on the ML problem of the model used for
  prediction. As input source the
  [gcs\_source][google.cloud.automl.v1beta1.InputConfig.gcs\_source] is
  expected, unless specified otherwise.
  
  The formats are represented in EBNF with commas being literal and with
  non-terminal symbols defined near the end of this comment. The formats
  are:
  
  -  For Image Classification: CSV file(s) with each line having just a
     single column: GCS\_FILE\_PATH which leads to image of up to 30MB in
     size. Supported extensions: .JPEG, .GIF, .PNG. This path is treated
     as the ID in the Batch predict output. Three sample rows:
     gs://folder/image1.jpeg gs://folder/image2.gif gs://folder/image3.png
  
  -  For Image Object Detection: CSV file(s) with each line having just a
     single column: GCS\_FILE\_PATH which leads to image of up to 30MB in
     size. Supported extensions: .JPEG, .GIF, .PNG. This path is treated
     as the ID in the Batch predict output. Three sample rows:
     gs://folder/image1.jpeg gs://folder/image2.gif gs://folder/image3.png
  -  For Video Classification: CSV file(s) with each line in format:
     GCS\_FILE\_PATH,TIME\_SEGMENT\_START,TIME\_SEGMENT\_END
     GCS\_FILE\_PATH leads to video of up to 50GB in size and up to 3h
     duration. Supported extensions: .MOV, .MPEG4, .MP4, .AVI.
     TIME\_SEGMENT\_START and TIME\_SEGMENT\_END must be within the length
     of the video, and end has to be after the start. Three sample rows:
     gs://folder/video1.mp4,10,40 gs://folder/video1.mp4,20,60
     gs://folder/vid2.mov,0,inf
  
  -  For Video Object Tracking: CSV file(s) with each line in format:
     GCS\_FILE\_PATH,TIME\_SEGMENT\_START,TIME\_SEGMENT\_END
     GCS\_FILE\_PATH leads to video of up to 50GB in size and up to 3h
     duration. Supported extensions: .MOV, .MPEG4, .MP4, .AVI.
     TIME\_SEGMENT\_START and TIME\_SEGMENT\_END must be within the length
     of the video, and end has to be after the start. Three sample rows:
     gs://folder/video1.mp4,10,240 gs://folder/video1.mp4,300,360
     gs://folder/vid2.mov,0,inf
  -  For Text Classification: CSV file(s) with each line having just a
     single column: GCS\_FILE\_PATH \| TEXT\_SNIPPET Any given text file
     can have size upto 128kB. Any given text snippet content must have
     60,000 characters or less. Three sample rows: gs://folder/text1.txt
     "Some text content to predict" gs://folder/text3.pdf Supported file
     extensions: .txt, .pdf
  
  -  For Text Sentiment: CSV file(s) with each line having just a single
     column: GCS\_FILE\_PATH \| TEXT\_SNIPPET Any given text file can have
     size upto 128kB. Any given text snippet content must have 500
     characters or less. Three sample rows: gs://folder/text1.txt "Some
     text content to predict" gs://folder/text3.pdf Supported file
     extensions: .txt, .pdf
  
  -  For Text Extraction .JSONL (i.e. JSON Lines) file(s) which either
     provide text in-line or as documents (for a single BatchPredict call
     only one of the these formats may be used). The in-line .JSONL
     file(s) contain per line a proto that wraps a temporary user-assigned
     TextSnippet ID (string up to 2000 characters long) called "id", a
     TextSnippet proto (in json representation) and zero or more
     TextFeature protos. Any given text snippet content must have 30,000
     characters or less, and also be UTF-8 NFC encoded (ASCII already is).
     The IDs provided should be unique. The document .JSONL file(s)
     contain, per line, a proto that wraps a Document proto with
     input\_config set. Only PDF documents are supported now, and each
     document must be up to 2MB large. Any given .JSONL file must be 100MB
     or smaller, and no more than 20 files may be given. 
  
  -  For Tables: Either
     [gcs\_source][google.cloud.automl.v1beta1.InputConfig.gcs\_source] or
  
  [bigquery\_source][google.cloud.automl.v1beta1.InputConfig.bigquery\_source].
  GCS case: CSV file(s), each by itself 10GB or smaller and total size
  must be 100GB or smaller, where first file must have a header containing
  column names. If the first row of a subsequent file is the same as the
  header, then it is also treated as a header. All other rows contain
  values for the corresponding columns. The column names must contain the
  model's
  
  [input\_feature\_column\_specs'][google.cloud.automl.v1beta1.TablesModelMetadata.input\_feature\_column\_specs]
  
  [display\_name-s][google.cloud.automl.v1beta1.ColumnSpec.display\_name]
  (order doesn't matter). The columns corresponding to the model's input
  feature column specs must contain values compatible with the column
  spec's data types. Prediction on all the rows, i.e. the CSV lines, will
  be attempted. For FORECASTING
  
  [prediction\_type][google.cloud.automl.v1beta1.TablesModelMetadata.prediction\_type]:
  all columns having
  
  [TIME\_SERIES\_AVAILABLE\_PAST\_ONLY][google.cloud.automl.v1beta1.ColumnSpec.ForecastingMetadata.ColumnType]
  type will be ignored. First three sample rows of a CSV file: "First
  Name","Last Name","Dob","Addresses"
  
  "John","Doe","1968-01-22","[{"status":"current","address":"123\_First\_Avenue","city":"Seattle","state":"WA","zip":"11111","numberOfYears":"1"},{"status":"previous","address":"456\_Main\_Street","city":"Portland","state":"OR","zip":"22222","numberOfYears":"5"}]"
  
  "Jane","Doe","1980-10-16","[{"status":"current","address":"789\_Any\_Avenue","city":"Albany","state":"NY","zip":"33333","numberOfYears":"2"},{"status":"previous","address":"321\_Main\_Street","city":"Hoboken","state":"NJ","zip":"44444","numberOfYears":"3"}]}
  BigQuery case: An URI of a BigQuery table. The user data size of the
  BigQuery table must be 100GB or smaller. The column names must contain
  the model's
  
  [input\_feature\_column\_specs'][google.cloud.automl.v1beta1.TablesModelMetadata.input\_feature\_column\_specs]
  
  [display\_name-s][google.cloud.automl.v1beta1.ColumnSpec.display\_name]
  (order doesn't matter). The columns corresponding to the model's input
  feature column specs must contain values compatible with the column
  spec's data types. Prediction on all the rows of the table will be
  attempted. For FORECASTING
  
  [prediction\_type][google.cloud.automl.v1beta1.TablesModelMetadata.prediction\_type]:
  all columns having
  
  [TIME\_SERIES\_AVAILABLE\_PAST\_ONLY][google.cloud.automl.v1beta1.ColumnSpec.ForecastingMetadata.ColumnType]
  type will be ignored.
  
  Definitions: GCS\_FILE\_PATH = A path to file on GCS, e.g.
  "gs://folder/video.avi". TEXT\_SNIPPET = A content of a text snippet,
  UTF-8 encoded, enclosed within double quotes ("") TIME\_SEGMENT\_START =
  TIME\_OFFSET Expresses a beginning, inclusive, of a time segment within
  an example that has a time dimension (e.g. video). TIME\_SEGMENT\_END =
  TIME\_OFFSET Expresses an end, exclusive, of a time segment within an
  example that has a time dimension (e.g. video). TIME\_OFFSET = A number
  of seconds as measured from the start of an example (e.g. video).
  Fractions are allowed, up to a microsecond precision. "inf" is allowed
  and it means the end of the example.
  
  Errors: If any of the provided CSV files can't be parsed or if more than
  certain percent of CSV rows cannot be processed then the operation fails
  and prediction does not happen. Regardless of overall success or failure
  the per-row failures, up to a certain count cap, will be listed in
  Operation.metadata.partial\_failures.
  
  
  Attributes:
      source:
          Required. The source of the input.
      gcs_source:
          The Google Cloud Storage location for the input content.
      bigquery_source:
          The BigQuery location for the input content.
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.BatchPredictInputConfig)
    ),
)
_sym_db.RegisterMessage(BatchPredictInputConfig)

DocumentInputConfig = _reflection.GeneratedProtocolMessageType(
    "DocumentInputConfig",
    (_message.Message,),
    dict(
        DESCRIPTOR=_DOCUMENTINPUTCONFIG,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""Input configuration of a
  [Document][google.cloud.automl.v1beta1.Document].
  
  
  Attributes:
      gcs_source:
          The Google Cloud Storage location of the document file. Only a
          single path should be given. Max supported size: 512MB.
          Supported extensions: .PDF.
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.DocumentInputConfig)
    ),
)
_sym_db.RegisterMessage(DocumentInputConfig)

OutputConfig = _reflection.GeneratedProtocolMessageType(
    "OutputConfig",
    (_message.Message,),
    dict(
        DESCRIPTOR=_OUTPUTCONFIG,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""
-  For Translation: CSV file ``translation.csv``, with each line in
     format: ML\_USE,GCS\_FILE\_PATH GCS\_FILE\_PATH leads to a .TSV file
     which describes examples that have given ML\_USE, using the following
     row format per line: TEXT\_SNIPPET (in source language)
     \\tTEXT\_SNIPPET (in target language)
  
  -  For Tables: Output depends on whether the dataset was imported from
     GCS or BigQuery. GCS case:
  
  [gcs\_destination][google.cloud.automl.v1beta1.OutputConfig.gcs\_destination]
  must be set. Exported are CSV file(s) ``tables_1.csv``,
  ``tables_2.csv``,...,\ ``tables_N.csv`` with each having as header line
  the table's column names, and all other lines contain values for the
  header columns. BigQuery case:
  
  [bigquery\_destination][google.cloud.automl.v1beta1.OutputConfig.bigquery\_destination]
  pointing to a BigQuery project must be set. In the given project a new
  dataset will be created with name
  
  ``export_data_<automl-dataset-display-name>_<timestamp-of-export-call>``
  where will be made BigQuery-dataset-name compatible (e.g. most special
  characters will become underscores), and timestamp will be in
  YYYY\_MM\_DDThh\_mm\_ss\_sssZ "based on ISO-8601" format. In that
  dataset a new table called ``primary_table`` will be created, and filled
  with precisely the same data as this obtained on import.
  
  
  Attributes:
      destination:
          Required. The destination of the output.
      gcs_destination:
          The Google Cloud Storage location where the output is to be
          written to. For Image Object Detection, Text Extraction, Video
          Classification and Tables, in the given directory a new
          directory will be created with name: export\_data-- where
          timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format. All
          export output will be written into that directory.
      bigquery_destination:
          The BigQuery location where the output is to be written to.
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.OutputConfig)
    ),
)
_sym_db.RegisterMessage(OutputConfig)

BatchPredictOutputConfig = _reflection.GeneratedProtocolMessageType(
    "BatchPredictOutputConfig",
    (_message.Message,),
    dict(
        DESCRIPTOR=_BATCHPREDICTOUTPUTCONFIG,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""Output configuration for BatchPredict Action.
  
  As destination the
  
  [gcs\_destination][google.cloud.automl.v1beta1.BatchPredictOutputConfig.gcs\_destination]
  must be set unless specified otherwise for a domain. If gcs\_destination
  is set then in the given directory a new directory is created. Its name
  will be "prediction--", where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ
  ISO-8601 format. The contents of it depends on the ML problem the
  predictions are made for.
  
  -  For Image Classification: In the created directory files
     ``image_classification_1.jsonl``,
     ``image_classification_2.jsonl``,...,\ ``image_classification_N.jsonl``
     will be created, where N may be 1, and depends on the total number of
     the successfully predicted images and annotations. A single image
     will be listed only once with all its annotations, and its
     annotations will never be split across files. Each .JSONL file will
     contain, per line, a JSON representation of a proto that wraps
     image's "ID" : "" followed by a list of zero or more
     AnnotationPayload protos (called annotations), which have
     classification detail populated. If prediction for any image failed
     (partially or completely), then an additional ``errors_1.jsonl``,
     ``errors_2.jsonl``,..., ``errors_N.jsonl`` files will be created (N
     depends on total number of failed predictions). These files will have
     a JSON representation of a proto that wraps the same "ID" : "" but
     here followed by exactly one
  
  ```google.rpc.Status`` <https:%20//github.com/googleapis/googleapis/blob/master/google/rpc/status.proto>`__
  containing only ``code`` and ``message``\ fields.
  
  -  For Image Object Detection: In the created directory files
     ``image_object_detection_1.jsonl``,
     ``image_object_detection_2.jsonl``,...,\ ``image_object_detection_N.jsonl``
     will be created, where N may be 1, and depends on the total number of
     the successfully predicted images and annotations. Each .JSONL file
     will contain, per line, a JSON representation of a proto that wraps
     image's "ID" : "" followed by a list of zero or more
     AnnotationPayload protos (called annotations), which have
     image\_object\_detection detail populated. A single image will be
     listed only once with all its annotations, and its annotations will
     never be split across files. If prediction for any image failed
     (partially or completely), then additional ``errors_1.jsonl``,
     ``errors_2.jsonl``,..., ``errors_N.jsonl`` files will be created (N
     depends on total number of failed predictions). These files will have
     a JSON representation of a proto that wraps the same "ID" : "" but
     here followed by exactly one
  
  ```google.rpc.Status`` <https:%20//github.com/googleapis/googleapis/blob/master/google/rpc/status.proto>`__
  containing only ``code`` and ``message``\ fields. \* For Video
  Classification: In the created directory a video\_classification.csv
  file, and a .JSON file per each video classification requested in the
  input (i.e. each line in given CSV(s)), will be created.
  
  ::
  
          The format of video_classification.csv is:
  
  GCS\_FILE\_PATH,TIME\_SEGMENT\_START,TIME\_SEGMENT\_END,JSON\_FILE\_NAME,STATUS
  where: GCS\_FILE\_PATH,TIME\_SEGMENT\_START,TIME\_SEGMENT\_END = matches
  1 to 1 the prediction input lines (i.e. video\_classification.csv has
  precisely the same number of lines as the prediction input had.)
  JSON\_FILE\_NAME = Name of .JSON file in the output directory, which
  contains prediction responses for the video time segment. STATUS = "OK"
  if prediction completed successfully, or an error code with message
  otherwise. If STATUS is not "OK" then the .JSON file for that line may
  not exist or be empty.
  
  ::
  
          Each .JSON file, assuming STATUS is "OK", will contain a list of
          AnnotationPayload protos in JSON format, which are the predictions
          for the video time segment the file is assigned to in the
          video_classification.csv. All AnnotationPayload protos will have
          video_classification field set, and will be sorted by
          video_classification.type field (note that the returned types are
          governed by `classifaction_types` parameter in
          [PredictService.BatchPredictRequest.params][]).
  
  -  For Video Object Tracking: In the created directory a
     video\_object\_tracking.csv file will be created, and multiple files
     video\_object\_trackinng\_1.json,
     video\_object\_trackinng\_2.json,...,
     video\_object\_trackinng\_N.json, where N is the number of requests
     in the input (i.e. the number of lines in given CSV(s)).
  
     ::
  
         The format of video_object_tracking.csv is:
  
  GCS\_FILE\_PATH,TIME\_SEGMENT\_START,TIME\_SEGMENT\_END,JSON\_FILE\_NAME,STATUS
  where: GCS\_FILE\_PATH,TIME\_SEGMENT\_START,TIME\_SEGMENT\_END = matches
  1 to 1 the prediction input lines (i.e. video\_object\_tracking.csv has
  precisely the same number of lines as the prediction input had.)
  JSON\_FILE\_NAME = Name of .JSON file in the output directory, which
  contains prediction responses for the video time segment. STATUS = "OK"
  if prediction completed successfully, or an error code with message
  otherwise. If STATUS is not "OK" then the .JSON file for that line may
  not exist or be empty.
  
  ::
  
          Each .JSON file, assuming STATUS is "OK", will contain a list of
          AnnotationPayload protos in JSON format, which are the predictions
          for each frame of the video time segment the file is assigned to in
          video_object_tracking.csv. All AnnotationPayload protos will have
          video_object_tracking field set.
  
  -  For Text Classification: In the created directory files
     ``text_classification_1.jsonl``,
     ``text_classification_2.jsonl``,...,\ ``text_classification_N.jsonl``
     will be created, where N may be 1, and depends on the total number of
     inputs and annotations found.
  
     ::
  
         Each .JSONL file will contain, per line, a JSON representation of a
         proto that wraps input text snippet or input text file and a list of
         zero or more AnnotationPayload protos (called annotations), which
         have classification detail populated. A single text snippet or file
         will be listed only once with all its annotations, and its
         annotations will never be split across files.
  
         If prediction for any text snippet or file failed (partially or
         completely), then additional `errors_1.jsonl`, `errors_2.jsonl`,...,
         `errors_N.jsonl` files will be created (N depends on total number of
         failed predictions). These files will have a JSON representation of a
         proto that wraps input text snippet or input text file followed by
         exactly one
  
  ```google.rpc.Status`` <https:%20//github.com/googleapis/googleapis/blob/master/google/rpc/status.proto>`__
  containing only ``code`` and ``message``.
  
  -  For Text Sentiment: In the created directory files
     ``text_sentiment_1.jsonl``,
     ``text_sentiment_2.jsonl``,...,\ ``text_sentiment_N.jsonl`` will be
     created, where N may be 1, and depends on the total number of inputs
     and annotations found.
  
     ::
  
         Each .JSONL file will contain, per line, a JSON representation of a
         proto that wraps input text snippet or input text file and a list of
         zero or more AnnotationPayload protos (called annotations), which
         have text_sentiment detail populated. A single text snippet or file
         will be listed only once with all its annotations, and its
         annotations will never be split across files.
  
         If prediction for any text snippet or file failed (partially or
         completely), then additional `errors_1.jsonl`, `errors_2.jsonl`,...,
         `errors_N.jsonl` files will be created (N depends on total number of
         failed predictions). These files will have a JSON representation of a
         proto that wraps input text snippet or input text file followed by
         exactly one
  
  ```google.rpc.Status`` <https:%20//github.com/googleapis/googleapis/blob/master/google/rpc/status.proto>`__
  containing only ``code`` and ``message``.
  
  -  For Text Extraction: In the created directory files
     ``text_extraction_1.jsonl``,
     ``text_extraction_2.jsonl``,...,\ ``text_extraction_N.jsonl`` will be
     created, where N may be 1, and depends on the total number of inputs
     and annotations found. The contents of these .JSONL file(s) depend on
     whether the input used inline text, or documents. If input was
     inline, then each .JSONL file will contain, per line, a JSON
     representation of a proto that wraps given in request text snippet's
     "id" (if specified), followed by input text snippet, and a list of
     zero or more AnnotationPayload protos (called annotations), which
     have text\_extraction detail populated. A single text snippet will be
     listed only once with all its annotations, and its annotations will
     never be split across files. If input used documents, then each
     .JSONL file will contain, per line, a JSON representation of a proto
     that wraps given in request document proto, followed by its OCR-ed
     representation in the form of a text snippet, finally followed by a
     list of zero or more AnnotationPayload protos (called annotations),
     which have text\_extraction detail populated and refer, via their
     indices, to the OCR-ed text snippet. A single document (and its text
     snippet) will be listed only once with all its annotations, and its
     annotations will never be split across files. If prediction for any
     text snippet failed (partially or completely), then additional
     ``errors_1.jsonl``, ``errors_2.jsonl``,..., ``errors_N.jsonl`` files
     will be created (N depends on total number of failed predictions).
     These files will have a JSON representation of a proto that wraps
     either the "id" : "" (in case of inline) or the document proto (in
     case of document) but here followed by exactly one
  
  ```google.rpc.Status`` <https:%20//github.com/googleapis/googleapis/blob/master/google/rpc/status.proto>`__
  containing only ``code`` and ``message``.
  
  -  For Tables: Output depends on whether
  
  [gcs\_destination][google.cloud.automl.v1beta1.BatchPredictOutputConfig.gcs\_destination]
  or
  
  [bigquery\_destination][google.cloud.automl.v1beta1.BatchPredictOutputConfig.bigquery\_destination]
  is set (either is allowed). GCS case: In the created directory files
  ``tables_1.csv``, ``tables_2.csv``,..., ``tables_N.csv`` will be
  created, where N may be 1, and depends on the total number of the
  successfully predicted rows. For all CLASSIFICATION
  
  [prediction\_type-s][google.cloud.automl.v1beta1.TablesModelMetadata.prediction\_type]:
  Each .csv file will contain a header, listing all columns'
  
  [display\_name-s][google.cloud.automl.v1beta1.ColumnSpec.display\_name]
  given on input followed by M target column names in the format of
  
  "<[target\_column\_specs][google.cloud.automl.v1beta1.TablesModelMetadata.target\_column\_spec]
  
  [display\_name][google.cloud.automl.v1beta1.ColumnSpec.display\_name]>\_\_score"
  where M is the number of distinct target values, i.e. number of distinct
  values in the target column of the table used to train the model.
  Subsequent lines will contain the respective values of successfully
  predicted rows, with the last, i.e. the target, columns having the
  corresponding prediction
  [scores][google.cloud.automl.v1beta1.TablesAnnotation.score]. For
  REGRESSION and FORECASTING
  
  [prediction\_type-s][google.cloud.automl.v1beta1.TablesModelMetadata.prediction\_type]:
  Each .csv file will contain a header, listing all columns'
  [display\_name-s][google.cloud.automl.v1beta1.display\_name] given on
  input followed by the predicted target column with name in the format of
  
  "predicted\_<[target\_column\_specs][google.cloud.automl.v1beta1.TablesModelMetadata.target\_column\_spec]
  
  [display\_name][google.cloud.automl.v1beta1.ColumnSpec.display\_name]>"
  Subsequent lines will contain the respective values of successfully
  predicted rows, with the last, i.e. the target, column having the
  predicted target value. If prediction for any rows failed, then an
  additional ``errors_1.csv``, ``errors_2.csv``,..., ``errors_N.csv`` will
  be created (N depends on total number of failed rows). These files will
  have analogous format as ``tables_*.csv``, but always with a single
  target column having
  
  ```google.rpc.Status`` <https:%20//github.com/googleapis/googleapis/blob/master/google/rpc/status.proto>`__
  represented as a JSON string, and containing only ``code`` and
  ``message``. BigQuery case:
  
  [bigquery\_destination][google.cloud.automl.v1beta1.OutputConfig.bigquery\_destination]
  pointing to a BigQuery project must be set. In the given project a new
  dataset will be created with name
  ``prediction_<model-display-name>_<timestamp-of-prediction-call>`` where
  will be made BigQuery-dataset-name compatible (e.g. most special
  characters will become underscores), and timestamp will be in
  YYYY\_MM\_DDThh\_mm\_ss\_sssZ "based on ISO-8601" format. In the dataset
  two tables will be created, ``predictions``, and ``errors``. The
  ``predictions`` table's column names will be the input columns'
  
  [display\_name-s][google.cloud.automl.v1beta1.ColumnSpec.display\_name]
  followed by the target column with name in the format of
  
  "predicted\_<[target\_column\_specs][google.cloud.automl.v1beta1.TablesModelMetadata.target\_column\_spec]
  
  [display\_name][google.cloud.automl.v1beta1.ColumnSpec.display\_name]>"
  The input feature columns will contain the respective values of
  successfully predicted rows, with the target column having an ARRAY of
  
  [AnnotationPayloads][google.cloud.automl.v1beta1.AnnotationPayload],
  represented as STRUCT-s, containing
  [TablesAnnotation][google.cloud.automl.v1beta1.TablesAnnotation]. The
  ``errors`` table contains rows for which the prediction has failed, it
  has analogous input columns while the target column name is in the
  format of
  
  "errors\_<[target\_column\_specs][google.cloud.automl.v1beta1.TablesModelMetadata.target\_column\_spec]
  
  [display\_name][google.cloud.automl.v1beta1.ColumnSpec.display\_name]>",
  and as a value has
  
  ```google.rpc.Status`` <https:%20//github.com/googleapis/googleapis/blob/master/google/rpc/status.proto>`__
  represented as a STRUCT, and containing only ``code`` and ``message``.
  
  
  Attributes:
      destination:
          Required. The destination of the output.
      gcs_destination:
          The Google Cloud Storage location of the directory where the
          output is to be written to.
      bigquery_destination:
          The BigQuery location where the output is to be written to.
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.BatchPredictOutputConfig)
    ),
)
_sym_db.RegisterMessage(BatchPredictOutputConfig)

ModelExportOutputConfig = _reflection.GeneratedProtocolMessageType(
    "ModelExportOutputConfig",
    (_message.Message,),
    dict(
        ParamsEntry=_reflection.GeneratedProtocolMessageType(
            "ParamsEntry",
            (_message.Message,),
            dict(
                DESCRIPTOR=_MODELEXPORTOUTPUTCONFIG_PARAMSENTRY,
                __module__="google.cloud.automl_v1beta1.proto.io_pb2"
                # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.ModelExportOutputConfig.ParamsEntry)
            ),
        ),
        DESCRIPTOR=_MODELEXPORTOUTPUTCONFIG,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""Output configuration for ModelExport Action.
  
  
  Attributes:
      destination:
          Required. The destination of the output.
      gcs_destination:
          The Google Cloud Storage location where the model is to be
          written to. This location may only be set for the following
          model formats: "tflite", "edgetpu\_tflite", "core\_ml",
          "docker".  Under the directory given as the destination a new
          one with name "model-export--", where timestamp is in YYYY-MM-
          DDThh:mm:ss.sssZ ISO-8601 format, will be created. Inside the
          model and any of its supporting files will be written.
      gcr_destination:
          The GCR location where model image is to be pushed to. This
          location may only be set for the following model formats:
          "docker".  The model image will be created under the given
          URI.
      model_format:
          The format in which the model must be exported. The available,
          and default, formats depend on the problem and model type (if
          given problem and type combination doesn't have a format
          listed, it means its models are not exportable):  -  For Image
          Classification mobile-low-latency-1, mobile-versatile-1,
          mobile-high-accuracy-1: "tflite" (default), "edgetpu\_tflite",
          "tf\_saved\_model", "docker".  -  For Image Classification
          mobile-core-ml-low-latency-1,    mobile-core-ml-versatile-1,
          mobile-core-ml-high-accuracy-1:    "core\_ml" (default).
          Formats description:  -  tflite - Used for Android mobile
          devices. -  edgetpu\_tflite - Used for `Edge    TPU
          <https://cloud.google.com/edge-tpu/>`__ devices. -
          tf\_saved\_model - A tensorflow model in SavedModel format. -
          docker - Used for Docker containers. Use the params field to
          customize the container. The container is verified to work
          correctly    on ubuntu 16.04 operating system. See more at
          [containers  quickstart](https:
          //cloud.google.com/vision/automl/docs/containers-gcs-
          quickstart) \* core\_ml - Used for iOS mobile devices.
      params:
          Additional model-type and format specific parameters
          describing the requirements for the to be exported model
          files, any string must be up to 25000 characters long.  -  For
          ``docker`` format: ``cpu_architecture`` - (string) "x86\_64"
          (default). ``gpu_architecture`` - (string) "none" (default),
          "nvidia".
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.ModelExportOutputConfig)
    ),
)
_sym_db.RegisterMessage(ModelExportOutputConfig)
_sym_db.RegisterMessage(ModelExportOutputConfig.ParamsEntry)

ExportEvaluatedExamplesOutputConfig = _reflection.GeneratedProtocolMessageType(
    "ExportEvaluatedExamplesOutputConfig",
    (_message.Message,),
    dict(
        DESCRIPTOR=_EXPORTEVALUATEDEXAMPLESOUTPUTCONFIG,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""Output configuration for ExportEvaluatedExamples Action. Note that this
  call is available only for 30 days since the moment the model was
  evaluated. The output depends on the domain, as follows (note that only
  examples from the TEST set are exported):
  
  -  For Tables:
  
  [bigquery\_destination][google.cloud.automl.v1beta1.OutputConfig.bigquery\_destination]
  pointing to a BigQuery project must be set. In the given project a new
  dataset will be created with name
  
  ``export_evaluated_examples_<model-display-name>_<timestamp-of-export-call>``
  where will be made BigQuery-dataset-name compatible (e.g. most special
  characters will become underscores), and timestamp will be in
  YYYY\_MM\_DDThh\_mm\_ss\_sssZ "based on ISO-8601" format. In the dataset
  an ``evaluated_examples`` table will be created. It will have all the
  same columns as the
  
  [primary\_table][google.cloud.automl.v1beta1.TablesDatasetMetadata.primary\_table\_spec\_id]
  of the [dataset][google.cloud.automl.v1beta1.Model.dataset\_id] from
  which the model was created, as they were at the moment of model's
  evaluation (this includes the target column with its ground truth),
  followed by a column called "predicted\_". That last column will contain
  the model's prediction result for each respective row, given as ARRAY of
  [AnnotationPayloads][google.cloud.automl.v1beta1.AnnotationPayload],
  represented as STRUCT-s, containing
  [TablesAnnotation][google.cloud.automl.v1beta1.TablesAnnotation].
  
  
  Attributes:
      destination:
          Required. The destination of the output.
      bigquery_destination:
          The BigQuery location where the output is to be written to.
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.ExportEvaluatedExamplesOutputConfig)
    ),
)
_sym_db.RegisterMessage(ExportEvaluatedExamplesOutputConfig)

GcsSource = _reflection.GeneratedProtocolMessageType(
    "GcsSource",
    (_message.Message,),
    dict(
        DESCRIPTOR=_GCSSOURCE,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""The Google Cloud Storage location for the input content.
  
  
  Attributes:
      input_uris:
          Required. Google Cloud Storage URIs to input files, up to 2000
          characters long. Accepted forms: \* Full object path, e.g.
          gs://bucket/directory/object.csv
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.GcsSource)
    ),
)
_sym_db.RegisterMessage(GcsSource)

BigQuerySource = _reflection.GeneratedProtocolMessageType(
    "BigQuerySource",
    (_message.Message,),
    dict(
        DESCRIPTOR=_BIGQUERYSOURCE,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""The BigQuery location for the input content.
  
  
  Attributes:
      input_uri:
          Required. BigQuery URI to a table, up to 2000 characters long.
          Accepted forms: \* BigQuery path e.g.
          bq://projectId.bqDatasetId.bqTableId
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.BigQuerySource)
    ),
)
_sym_db.RegisterMessage(BigQuerySource)

GcsDestination = _reflection.GeneratedProtocolMessageType(
    "GcsDestination",
    (_message.Message,),
    dict(
        DESCRIPTOR=_GCSDESTINATION,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""The Google Cloud Storage location where the output is to be written to.
  
  
  Attributes:
      output_uri_prefix:
          Required. Google Cloud Storage URI to output directory, up to
          2000 characters long. Accepted forms: \* Prefix path:
          gs://bucket/directory The requesting user must have write
          permission to the bucket. The directory is created if it
          doesn't exist.
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.GcsDestination)
    ),
)
_sym_db.RegisterMessage(GcsDestination)

BigQueryDestination = _reflection.GeneratedProtocolMessageType(
    "BigQueryDestination",
    (_message.Message,),
    dict(
        DESCRIPTOR=_BIGQUERYDESTINATION,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""The BigQuery location for the output content.
  
  
  Attributes:
      output_uri:
          Required. BigQuery URI to a project, up to 2000 characters
          long. Accepted forms: \* BigQuery path e.g. bq://projectId
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.BigQueryDestination)
    ),
)
_sym_db.RegisterMessage(BigQueryDestination)

GcrDestination = _reflection.GeneratedProtocolMessageType(
    "GcrDestination",
    (_message.Message,),
    dict(
        DESCRIPTOR=_GCRDESTINATION,
        __module__="google.cloud.automl_v1beta1.proto.io_pb2",
        __doc__="""The GCR location where the image must be pushed to.
  
  
  Attributes:
      output_uri:
          Required. Google Contained Registry URI of the new image, up
          to 2000 characters long. See  https:
          //cloud.google.com/container-registry/do // cs/pushing-and-
          pulling#pushing\_an\_image\_to\_a\_registry Accepted forms: \*
          [HOSTNAME]/[PROJECT-ID]/[IMAGE] \* [HOSTNAME]/[PROJECT-
          ID]/[IMAGE]:[TAG]  The requesting user must have permission to
          push images the project.
  """,
        # @@protoc_insertion_point(class_scope:google.cloud.automl.v1beta1.GcrDestination)
    ),
)
_sym_db.RegisterMessage(GcrDestination)


DESCRIPTOR._options = None
_INPUTCONFIG_PARAMSENTRY._options = None
_MODELEXPORTOUTPUTCONFIG_PARAMSENTRY._options = None
# @@protoc_insertion_point(module_scope)
